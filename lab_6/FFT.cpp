/*Алгоритм работает следующим образом:

Разделение: Делит входной массив на две части: элементы с четными индексами и с нечетными индексами.
Рекурсия: Рекурсивно применяет ДПФ к каждому подмассиву.
Смешивание: Объединяет результаты, применяя известные тригонометрические свойства.
*/

#include <iostream>
#include <vector>
#include <complex>
#include <cmath>

using namespace std;

// счетчик комплексных умножений
int counter = 0;

// Используем тип complex для работы с комплексными числами
typedef complex<double> Complex; // Complex: Используется для представления комплексных чисел.
typedef vector<Complex> CArray;  // CArray: Упрощает работу с вектором комплексных чисел.

/*
Функция для рекурсивного применения БПФ
Проверяет размер массива. Если он меньше или равен 1, то возвращается.
Делит исходный массив на два подмассива: четные и нечетные индексы.
Рекурсивно вызывает саму себя для обоих подмассивов.
Далее, смешивает результаты с использованием тригонометрических функций.
*/
void FFT(CArray &x)
{
    const size_t N = x.size();
    if (N <= 1)
        return; // Базовый случай: массив размера 1

    // Разделение массива на четные и нечетные индексы
    CArray even(N / 2), odd(N / 2);
    for (size_t i = 0; i < N / 2; ++i)
    {
        even[i] = x[i * 2];    // Чётные индексы
        odd[i] = x[i * 2 + 1]; // Нечётные индексы
    }

    // Рекурсивное применение БПФ
    FFT(even);
    FFT(odd);

    // Смешивание результатов
    for (size_t k = 0; k < N / 2; ++k)
    {
        // Экспоненциальный множитель
        Complex t = polar(1.0, -2 * M_PI * k / N) * odd[k]; // e^(-2 * pi * i * k / N)
        x[k] = even[k] + t;                                 // Чётные
        x[k + N / 2] = even[k] - t;                         // Нечётные
        counter++;
    }
}

/*
Основная функция для проверки работы
Инициализирует массив комплексных чисел.
Применяет к нему алгоритм БПФ и выводит результат.
*/
int main()
{
    // Пример входных данных
    CArray data = {1.0, .0, .0, .0};

    // Применяем БПФ
    FFT(data);

    // Выводим результаты
    cout << "FFT Result:" << endl;
    for (const auto &value : data)
    {
        cout << value << endl; // Выводим комплексные числа
    }

    // Выводим количество комплексных умножений
    cout << "\nComplex multiplication counter: " << counter << endl;

    return 0;
}
